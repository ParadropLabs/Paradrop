from paradrop.lib.utils import dockerapi
from mock import patch, MagicMock

HOST_CONFIG1 = {'RestartPolicy': {'MaximumRetryCount': 5, 'Name': 'on-failure'}, 'NetworkMode': 'bridge', 'LxcConf': [], 'CapAdd': ['NET_ADMIN']}
HOST_CONFIG2 = {'RestartPolicy': {'MaximumRetryCount': 5, 'Name': 'on-failure'}, 'NetworkMode': 'bridge', 'PortBindings': {'80/tcp': [{'HostPort': '9000', 'HostIp': ''}]}, 'LxcConf': [], 'Dns': ['0.0.0.0', '8.8.8.8'], 'CapAdd': ['NET_ADMIN']}

DOCKER_CONF = """
# Docker systemd configuration
#
# This configuration file was automatically generated by Paradrop.  Any changes
# will be overwritten on startup.

# Tell docker not to start containers automatically on startup.
DOCKER_OPTIONS="--restart=false"
"""


def fake_update():
    class Object(object):
        pass

    update = Object()
    update.new = Object()
    return update

def test_build_host_config():
    """
    Test that the build_host_config function does it's job.
    """
    #Check that an empty host_config gives us certain default settings
    u = fake_update()
    res = dockerapi.build_host_config(u)
    print '\nExpected: ', HOST_CONFIG1, '\nResult: ', res, '\n'
    assert res == HOST_CONFIG1

    #Check that passing things through host_config works
    u = MagicMock()
    u.new.host_config = {'port_bindings': { 80:9000}, 'dns': ['0.0.0.0', '8.8.8.8']}
    res = dockerapi.build_host_config(u)
    print '\nExpected: ', HOST_CONFIG2, '\nResult: ', res, '\n'
    assert res == HOST_CONFIG2

@patch('paradrop.lib.utils.dockerapi.out')
@patch('docker.Client')
def test_failAndCleanUpDocker(mockDocker, mockOutput):
    """
    Test that the failure and clean up function does it's job.
    """
    client = MagicMock()
    mockDocker.return_value = client
    #call clean up with empty sets, matching sets, and different sets for valid and current images and test
    for pair in [[[],[]], [[1, 2, 3], [1, 2, 3]], [[{'Id': 1}, {'Id': 2}, {'Id': 3}], [{'Id': 1}, {'Id': 2}, {'Id': 3}, {'Id': 4}, {'Id': 5}]]]:
        #fake that docker is returning the second list in the pair as the current images and containers on the device
        client.containers.return_value = pair[1]
        client.images.return_value = pair[1]
        try:
            dockerapi.failAndCleanUpDocker(pair[0],pair[0])
        except Exception as e:
            #we should always see this exception
            assert e.message == 'Building or starting of docker image failed check your Dockerfile for errors.'
        mockDocker.assert_called_with(base_url='unix://var/run/docker.sock', version='auto')
        client.containers.assert_called_once_with(quiet=True, all=True)
        client.images.assert_called_once_with(quiet=True, all=False)
        if pair[1] == pair[0]:
            assert client.remove_image.call_count == 0
            assert client.remove_container.call_count == 0
        else:
            img_expected = "[call(image={'Id': 4}), call(image={'Id': 5})]"
            cntr_expected = "[call(container=4), call(container=5)]"
            assert str(client.remove_image.call_args_list) == img_expected
            assert str(client.remove_container.call_args_list) == cntr_expected
            assert client.remove_image.call_count == 2
            assert client.remove_container.call_count == 2
        client.reset_mock()

@patch('paradrop.lib.utils.dockerapi.setup_net_interfaces')
@patch('paradrop.lib.utils.dockerapi.out')
@patch('docker.Client')
def test_restartChute(mockDocker, mockOutput, mockInterfaces):
    """
    Test that the restartChute function does it's job.
    """
    update = MagicMock()
    update.name = 'test'
    client = MagicMock()
    mockDocker.return_value = client
    dockerapi.restartChute(update)
    mockDocker.assert_called_once_with(base_url='unix://var/run/docker.sock', version='auto')
    mockInterfaces.assert_called_once_with(update)
    client.start.assert_called_once_with(container=update.name)

@patch('paradrop.lib.utils.dockerapi.out')
@patch('docker.Client')
def test_stopChute(mockDocker, mockOutput):
    """
    Test that the stopChute function does it's job.
    """
    update = MagicMock()
    update.name = 'test'
    client = MagicMock()
    mockDocker.return_value = client
    dockerapi.stopChute(update)
    mockDocker.assert_called_once_with(base_url='unix://var/run/docker.sock', version='auto')
    client.stop.assert_called_once_with(container=update.name)

@patch('paradrop.lib.utils.dockerapi.out')
@patch('docker.Client')
def test_removeChute(mockDocker, mockOutput):
    """
    Test that the stopChute function does it's job.
    """
    update = MagicMock()
    update.name = 'test'
    client = MagicMock()
    mockDocker.return_value = client
    dockerapi.removeChute(update)
    mockDocker.assert_called_once_with(base_url='unix://var/run/docker.sock', version='auto')
    client.remove_container.assert_called_once_with(container=update.name, force=True)
    client.remove_image.assert_called_once_with(image='test:latest')
    assert update.complete.call_count == 0
    client.reset_mock()
    client.remove_container.side_effect = Exception('Test')
    try:
        dockerapi.removeChute(update)
    except Exception as e:
        assert e.message == 'Test'
    client.remove_container.assert_called_once_with(container=update.name, force=True)
    assert update.complete.call_count == 1

@patch('paradrop.lib.utils.dockerapi.failAndCleanUpDocker')
@patch('paradrop.lib.utils.dockerapi.build_host_config')
@patch('paradrop.lib.utils.dockerapi.setup_net_interfaces')
@patch('paradrop.lib.utils.dockerapi.out')
@patch('docker.Client')
def test_startChute(mockDocker, mockOutput, mockInterfaces, mockConfig, mockFail):
    """
    Test that the startChute function does it's job.
    """
    #Test successful start attempt
    mockConfig.return_value = 'ConfigDict'
    update = MagicMock()
    update.name = 'test'
    update.dockerfile = 'Dockerfile'
    client = MagicMock()
    client.images.return_value = 'images'
    client.containers.return_value = 'containers'
    client.build.return_value = ['{"stream": "test"}','{"value": {"test": "testing"}}','{"tests": "stuff"}']
    client.create_container.return_value = {'Id': 123}
    mockDocker.return_value = client
    dockerapi.startChute(update)
    mockConfig.assert_called_once_with(update)
    mockDocker.assert_called_once_with(base_url='unix://var/run/docker.sock', version='auto')
    client.images.assert_called_once_with(quiet=True, all=False)
    client.containers.assert_called_once_with(quiet=True, all=True)
    client.build.assert_called_once_with(rm=True, tag='test:latest', fileobj='Dockerfile')
    client.create_container.assert_called_once_with(image='test:latest', name='test', host_config='ConfigDict')
    client.start.assert_called_once_with(123)
    assert update.pkg.request.write.call_count == 2
    mockInterfaces.assert_called_once_with(update)

    #Test failed build
    client.build.return_value = ['{"errorDetail": "Errors"}']
    dockerapi.startChute(update)
    mockFail.assert_called_once_with('images', 'containers')

    #Test when create or start throws exceptions
    mockFail.reset_mock()
    client.build.return_value = ['{"stream": "test"}','{"value": {"test": "testing"}}','{"tests": "stuff"}']
    client.create_container.side_effect = Exception('create container exception')
    dockerapi.startChute(update)
    mockFail.assert_called_once_with('images', 'containers')
    mockFail.reset_mock()
    client.start.side_effect = Exception('start exception')
    dockerapi.startChute(update)
    mockFail.assert_called_once_with('images', 'containers')

@patch('paradrop.lib.utils.dockerapi.os')
@patch('paradrop.lib.utils.dockerapi.subprocess')
@patch('paradrop.lib.utils.dockerapi.out')
def test_setup_net_interfaces(mockOutput, mockSubproc, mockOS):
    """
    Test that the setup_net_interfaces function does it's job.
    """
    #Test successful setup
    update = MagicMock()
    update.name = 'testing'
    update.new.getCache.return_value = [{'netType': 'wifi', 'ipaddrWithPrefix': '0.0.0.0/24', 'internalIntf': 'Inside', 'externalIntf': 'Outside'}, {'netType': 'lan'}]
    mockOS.environ.get.return_value  = ""
    proc = MagicMock()
    mockSubproc.Popen.return_value = proc
    mockSubproc.PIPE = 'piping'
    proc.stdout = ['test1', 'test2']
    proc.stderr = ['error']
    dockerapi.setup_net_interfaces(update)
    mockSubproc.Popen.assert_called_once_with(['/apps/paradrop/current/bin/pipework', 'Outside', '-i', 'Inside', update.name, '0.0.0.0/24' ],
            stdout=mockSubproc.PIPE, stderr=mockSubproc.PIPE, env={"PATH": ":/apps/bin"})

    #Test subprocess throwing an exception
    mockSubproc.Popen.side_effect = OSError('BAD!')
    try:
        dockerapi.setup_net_interfaces(update)
    except OSError as e:
        assert e.message == 'BAD!'

@patch('__builtin__.open')
@patch('paradrop.lib.utils.dockerapi.os')
@patch('paradrop.lib.utils.dockerapi.out')
def test_writeDockerConfig(mockOutput, mockOS, mock_open):
    """
    Test that the writeDockerConfig function does it's job.
    """
    fd = MagicMock()
    mock_open.return_value = fd
    #Test we get a warning and nothing else if path doesn't exist
    mockOS.path.exists.return_value = False
    dockerapi.writeDockerConfig()
    assert not mock_open.called
    assert len(mockOS.method_calls) == 1

    #Test that it writes if we find path
    mockOS.path.exists.side_effect = [True, False, True]
    mockOS.listdir.return_value = ['/root', '/var']
    dockerapi.writeDockerConfig()
    assert mock_open.call_count == 1
    file_handle = mock_open.return_value.__enter__.return_value
    file_handle.write.assert_called_once_with(DOCKER_CONF)

    #Test that we handle an excpetion when opening
    mockOS.path.exists.side_effect = None
    mockOS.path.exists.return_value = True
    mockOS.listdir.return_value = ['/root']
    mock_open.side_effect = Exception('Blammo!')
    dockerapi.writeDockerConfig()
    assert mock_open.call_count == 2
